/********************************************************************************
 * Copyright (c) 2020 The Eclipse Foundation
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 * 
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
package ca.rideauosgoode.eclipse.asciidoctor.views;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;

import javax.inject.Inject;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.IPath;
import org.eclipse.jface.util.LocalSelectionTransfer;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.SWT;
import org.eclipse.swt.browser.Browser;
import org.eclipse.swt.dnd.DND;
import org.eclipse.swt.dnd.DropTarget;
import org.eclipse.swt.dnd.DropTargetAdapter;
import org.eclipse.swt.dnd.DropTargetEvent;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;
import org.eclipse.ui.IMemento;
import org.eclipse.ui.IViewSite;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.part.ViewPart;

/**
 * This is a pretty simple view that embeds a browser to display
 * an HTML file generated by Asciidoctor. The implementation is not
 * intended to be general, but rather assumes a great many things
 * about how it is used and how the source files are structured.
 * 
 * To use the view, the user needs to drop an "adoc" file from the
 * workspace onto the label at the top of the view. Armed with that,
 * the implementation assumes that there is a file named "convert.js"
 * in the same directory as the source file. That file is invoked
 * with <code>node</code> to rebuild the HTML content which is
 * assumed to have the same name as the source file, but with an
 * "html" extension.
 * 
 * There's also sorts of ways that we can consider generalizing this
 * if there is interest.
 */
public class AsciidoctorPreview extends ViewPart {

	/**
	 * The ID of the view as specified by the extension.
	 */
	public static final String ID = "ca.rideauosgoode.eclipse.asciidoctor.views.AsciidoctorPreview";

	@Inject IWorkbench workbench;

	private Browser browser;

	private IFile file;

	private Label label;

	private IResourceChangeListener resourceChangeListener;
	
	@Override
	public void init(IViewSite site, IMemento memento) throws PartInitException {
		super.init(site, memento);
		try {
			String data = memento.getString("file");
			if (data == null) return;
			IFile[] files = ResourcesPlugin.getWorkspace().getRoot().findFilesForLocationURI(new URI(data));
			if (files.length > 0) {
				site.getShell().getDisplay().asyncExec(() -> {
					renderFile(files[0]);
				});
			}
		} catch (URISyntaxException e) {
			// Maybe log this.
			// By just ignoring this exception (in the unlikely event that it
			// is ever triggered), we can recover gracefully.
		}
	}
	
	@Override
	public void createPartControl(Composite parent) {
		// Add the parts. I've added the label primarily because I 
		// couldn't sort out how to get the drop handler to work on the
		// browser.
		label = new Label(parent, SWT.NONE);
		label.setText("Drop an Asciidoc file here");
		browser = new Browser(parent, SWT.WEBKIT);
		browser.setText("hello");
		
		// Grid layout puts the label at the top; the browser takes up
		// all remaining space.
		GridLayout layout = new GridLayout(1, false);
		parent.setLayout(layout);
		label.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));
		browser.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
		
		// Configure drag and drop so that we can load the view.
		DropTarget target = new DropTarget(label, DND.DROP_DEFAULT | DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK);
		target.setTransfer(LocalSelectionTransfer.getTransfer());
		target.addDropListener(new DropTargetAdapter() {
			@Override
			public void drop(DropTargetEvent event) {
				if (event.data instanceof IStructuredSelection) {
					drop((IStructuredSelection)event.data);
				}
			}

			private void drop(IStructuredSelection data) {
				if (data.isEmpty()) return;
				Object file = data.getFirstElement();
				if (file instanceof IFile) {
					drop((IFile)file);
				}
			}

			private void drop(IFile file) {
				renderFile(file);
			}
		});
		
		// Install a resource change listener on the workspace. When
		// any file in the directory (or any subdirectory) that contains
		// our source file, rebuild the preview.
		resourceChangeListener = new IResourceChangeListener() {
			
			@Override
			public void resourceChanged(IResourceChangeEvent event) {
				if (file == null) return;
				if (event.getDelta() == null) return;
				IResourceDelta delta = event.getDelta().findMember(file.getParent().getFullPath());
				if (delta == null) return;
				if (delta.getResource().getType() == IResource.FILE) return;
				
				// Probably should use a job here, this could still
				// block the UI if the build job takes too long.
				parent.getDisplay().asyncExec(() -> {
					rebuild();
					browser.refresh();
				});
			}
		};
		ResourcesPlugin.getWorkspace().addResourceChangeListener(resourceChangeListener);
	}

	/**
	 * Save the state of the view when it closes. Next time the
	 * view opens, we'll look at the same file. We could also
	 * save the state of the browser (so, for example, we could
	 * open the browser on the same anchor).
	 */
	@Override
	public void saveState(IMemento memento) {
		if (file == null) return;
		memento.putString("file", file.getLocationURI().toString());
		super.saveState(memento);
	}
	
	@Override
	public void dispose() {
		// Be sure to clean up when we close.
		// All of the other handlers are on UI resources that are being
		// disposed as a matter of course, so we don't need to undo those.
		ResourcesPlugin.getWorkspace().removeResourceChangeListener(resourceChangeListener);
	}
	
	/**
	 * When we render a file, we get the build script to run to make
	 * sure that our preview content exists and is current.
	 * 
	 * In a perfect world, we should probably check that the file is
	 * actually Asciidoc source (maybe check the file extension as a minimum).
	 */
	protected void renderFile(IFile file) {
		this.file = file;
		rebuild();
		label.setText(file.getFullPath().toString());
		browser.setUrl(file.getRawLocation().removeFileExtension().addFileExtension("html").toString());
	}

	/**
	 * Generate the preview content. This assumes that a script named
	 * "convert.js" exists in the same directory as the source file, that
	 * calling node with this file will generate the preview, and that the
	 * preview file has the same name as the source file with an "html"
	 * extension.
	 * 
	 * We might generalize this by making it possible to select a build 
	 * file (pom.xml, something.js, ...) and otherwise configure how the
	 * preview is generated and what file it ends up in; or maybe leverage 
	 * AsciidoctorJ (at least as a default/fallback).
	 */
	private void rebuild() {
		if (file == null) return;
		if (!file.exists()) return;
		IPath path = file.getParent().getRawLocation();
		try {
			ProcessBuilder builder = new ProcessBuilder();
			builder.directory(new File(path.toOSString() + "/"));
			builder.command("/usr/bin/node", "convert.js");
			builder.start().waitFor();
		} catch (IOException | InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	@Override
	public void setFocus() {
		browser.setFocus();
	}
}
