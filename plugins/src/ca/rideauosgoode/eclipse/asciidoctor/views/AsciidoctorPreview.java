/********************************************************************************
 * Copyright (c) 2020 The Eclipse Foundation
 * 
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v. 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 * 
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
package ca.rideauosgoode.eclipse.asciidoctor.views;

import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.HashSet;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.inject.Inject;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.debug.core.DebugPlugin;
import org.eclipse.debug.core.ILaunch;
import org.eclipse.debug.core.ILaunchConfiguration;
import org.eclipse.debug.core.ILaunchDelegate;
import org.eclipse.debug.core.ILaunchListener;
import org.eclipse.debug.core.ILaunchManager;
import org.eclipse.debug.ui.DebugUITools;
import org.eclipse.jface.util.LocalSelectionTransfer;
import org.eclipse.jface.viewers.ComboViewer;
import org.eclipse.jface.viewers.IContentProvider;
import org.eclipse.jface.viewers.IStructuredContentProvider;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.swt.SWT;
import org.eclipse.swt.browser.Browser;
import org.eclipse.swt.browser.LocationListener;
import org.eclipse.swt.dnd.DND;
import org.eclipse.swt.dnd.DropTarget;
import org.eclipse.swt.dnd.DropTargetAdapter;
import org.eclipse.swt.dnd.DropTargetEvent;
import org.eclipse.swt.layout.GridData;
import org.eclipse.swt.layout.GridLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Label;
import org.eclipse.ui.IMemento;
import org.eclipse.ui.IViewSite;
import org.eclipse.ui.IWorkbench;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.part.ViewPart;

/**
 * This is a pretty simple view that embeds a browser to display
 * an HTML file generated by Asciidoctor. The implementation is not
 * intended to be general, but rather assumes a great many things
 * about how it is used and how the source files are structured.
 * 
 * To use the view, the user needs to drop an "adoc" file from the
 * workspace onto the label at the top of the view. Armed with that,
 * the implementation assumes that there is a file named "convert.js"
 * in the same directory as the source file. That file is invoked
 * with <code>node</code> to rebuild the HTML content which is
 * assumed to have the same name as the source file, but with an
 * "html" extension.
 * 
 * There's also sorts of ways that we can consider generalizing this
 * if there is interest.
 */
public class AsciidoctorPreview extends ViewPart {

	final class LaunchConfigurationLabelProvider extends LabelProvider {
		@Override
		public String getText(Object element) {
			ILaunchConfiguration launch = (ILaunchConfiguration)element;
			return launch.getName();
		}
	}

	final class LaunchConfigurationProvider implements IContentProvider, IStructuredContentProvider {

		private ILaunchListener launchListener;
		@Override
		public Object[] getElements(Object inputElement) {
			try {
				return DebugPlugin.getDefault().getLaunchManager().getLaunchConfigurations();
			} catch (CoreException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			return null;
		}
		
		@Override
		public void dispose() {
			DebugPlugin.getDefault().getLaunchManager().removeLaunchListener(launchListener);
		}
		
		@Override
		public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
			launchListener = new ILaunchListener() {
				
				@Override
				public void launchRemoved(ILaunch launch) {
					refresh(viewer);
				}
				
				@Override
				public void launchChanged(ILaunch launch) {
					refresh(viewer);
				}
				
				@Override
				public void launchAdded(ILaunch launch) {
					refresh(viewer);
				}

				private void refresh(Viewer viewer) {
					viewer.getControl().getDisplay().asyncExec(() -> 
						viewer.refresh());
				}
			};
			DebugPlugin.getDefault().getLaunchManager().addLaunchListener(launchListener);
		}

	}

	/**
	 * The ID of the view as specified by the extension.
	 */
	public static final String ID = "ca.rideauosgoode.eclipse.asciidoctor.views.AsciidoctorPreview";

	@Inject IWorkbench workbench;

	private Browser browser;

	private Label label;

	private IResourceChangeListener resourceChangeListener;

	private Job previewJob;

	private PreviewGenerator generator;
	
	@Override
	public void init(IViewSite site, IMemento memento) throws PartInitException {
		super.init(site, memento);
		try {
			if (memento == null) return;
			String data = memento.getString("file");
			if (data == null) return;
			IFile[] files = ResourcesPlugin.getWorkspace().getRoot().findFilesForLocationURI(new URI(data));
			if (files.length > 0) {
				createPreview(files[0]);
			}
		} catch (URISyntaxException e) {
			// Maybe log this.
			// By just ignoring this exception (in the unlikely event that it
			// is ever triggered), we can recover gracefully.
		}
	}
	
	@Override
	public void createPartControl(Composite parent) {

		
		label = new Label(parent, SWT.NONE);
		label.setText("Drop an Asciidoc file here");
		ComboViewer launches = new ComboViewer(parent, SWT.READ_ONLY|SWT.DROP_DOWN);
		browser = new Browser(parent, SWT.WEBKIT);
		browser.setText("hello");
		
		GridLayout layout = new GridLayout(1, false);
		parent.setLayout(layout);
		// Grid layout puts the label at the top; the browser takes up
		// all remaining space.
		label.setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));
		launches.getControl().setLayoutData(new GridData(SWT.FILL, SWT.TOP, true, false));
		browser.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));
		
		launches.setContentProvider(new LaunchConfigurationProvider());
		launches.setLabelProvider(new LaunchConfigurationLabelProvider());
		launches.setInput(new Object[] {});
		launches.addSelectionChangedListener(event -> {
			IStructuredSelection selection = event.getStructuredSelection();
			if (selection.isEmpty()) return;
			
			ILaunchConfiguration launch = (ILaunchConfiguration)selection.getFirstElement();
			try {
				ILaunchDelegate delegate = launch.getPreferredDelegate(new HashSet<String>(Collections.singletonList(ILaunchManager.DEBUG_MODE)));
				launch.getAttribute(DebugPlugin.ATTR_WORKING_DIRECTORY, "");
			} catch (CoreException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			DebugUITools.launch(launch, ILaunchManager.RUN_MODE, false);
		});
		browser.addLocationListener(LocationListener.changedAdapter(event -> {
			if (event.top) label.setText(event.location);
		}));
		
		// Configure drag and drop so that we can load the view.
		DropTarget target = new DropTarget(label, DND.DROP_DEFAULT | DND.DROP_MOVE | DND.DROP_COPY | DND.DROP_LINK);
		target.setTransfer(LocalSelectionTransfer.getTransfer());
		target.addDropListener(new DropTargetAdapter() {
			@Override
			public void drop(DropTargetEvent event) {
				if (event.data instanceof IStructuredSelection) {
					drop((IStructuredSelection)event.data);
				}
			}

			private void drop(IStructuredSelection data) {
				if (data.isEmpty()) return;
				Object file = data.getFirstElement();
				if (file instanceof IFile) {
					createPreview((IFile)file);
				}
			}

		});
		
		previewJob = new Job("Asciidoc preview") {
			protected IStatus run(IProgressMonitor monitor) {
				label.getDisplay().syncExec(() -> {
					label.setEnabled(false);
					browser.setEnabled(false);
				});
				IPath previewPath = rebuild();
				if (previewPath != null) {
					label.getDisplay().syncExec(() -> {
						if (browser == null) return;
						if (browser.isDisposed()) return;
						String url = browser.getUrl();
						if (matches(previewPath.toString(), url)) {
							browser.refresh();
						} else {
							browser.setUrl(previewPath.toString());
						}
						label.setEnabled(true);
						browser.setEnabled(true);
					});
				}
				return Status.OK_STATUS;
			}

			/*
			 * Answers true when the preview path would point the browser to the same
			 * URL that it's already pointing at. The preview path doesn't include
			 * any protocol or anchor; the URL (likely) does.
			 */
			private boolean matches(String previewPath, String url) {
				Matcher matcher = Pattern.compile("(file://)?"+Pattern.quote(previewPath)+"(#.*)?").matcher(url);
				return matcher.matches();
			}
		};
		previewJob.setPriority(Job.SHORT);
		
		// Install a resource change listener on the workspace. When
		// any file in the directory (or any subdirectory) that contains
		// our source file, rebuild the preview.
		resourceChangeListener = new IResourceChangeListener() {
			
			@Override
			public void resourceChanged(IResourceChangeEvent event) {
				if (generator == null) return;
				if (event.getDelta() == null) return;
				if (generator.ignorePaths(path -> event.getDelta().findMember(path) != null)) return;
				if (generator.resourcePaths(path -> event.getDelta().findMember(path) != null)) {
					updatePreview();
				}
			}
		};
		ResourcesPlugin.getWorkspace().addResourceChangeListener(resourceChangeListener);
		
		updatePreview();
	}
	
	private void createPreview(IFile file) {
		if (file == null) return;
		if (!file.exists()) return;
		IResource buildFile = file.getParent().findMember("convert.js");
		if (buildFile != null) {
			generator = new NodePreviewGenerator(file, buildFile);
		} else {
			buildFile = file.getParent().getParent().findMember("pom.xml");
			if (buildFile != null) {
				generator = new MavenPreviewGenerator(file, buildFile);
			}
		}
	}

	private void updatePreview() {
		if (generator == null) return;
		previewJob.schedule();
	}

	/**
	 * Save the state of the view when it closes. Next time the
	 * view opens, we'll look at the same file. We could also
	 * save the state of the browser (so, for example, we could
	 * open the browser on the same anchor).
	 */
	@Override
	public void saveState(IMemento memento) {
		if (generator == null) return;
		memento.putString("file", generator.getSourceFile().getLocationURI().toString());
		super.saveState(memento);
	}
	
	@Override
	public void dispose() {
		// Be sure to clean up when we close.
		// All of the other handlers are on UI resources that are being
		// disposed as a matter of course, so we don't need to undo those.
		ResourcesPlugin.getWorkspace().removeResourceChangeListener(resourceChangeListener);
	}
	
	/**
	 * Generate the preview content. This assumes that a script named
	 * "convert.js" exists in the same directory as the source file, that
	 * calling node with this file will generate the preview, and that the
	 * preview file has the same name as the source file with an "html"
	 * extension.
	 * 
	 * We might generalize this by making it possible to select a build 
	 * file (pom.xml, something.js, ...) and otherwise configure how the
	 * preview is generated and what file it ends up in; or maybe leverage 
	 * AsciidoctorJ (at least as a default/fallback).
	 */
	private IPath rebuild() {
		if (generator == null) return null;
		generator.generatePreview();
		return generator.getPreviewPath();
	}
	
	@Override
	public void setFocus() {
		browser.setFocus();
	}
	
	abstract class PreviewGenerator {
		final IFile file;
		final IResource buildFile;
		
		PreviewGenerator(IFile file, IResource buildFile) {
			this.file = file;
			this.buildFile = buildFile;
		}
		
		public IResource getSourceFile() {
			return file;
		}
		abstract void generatePreview();
		
		boolean ignorePaths(Function<IPath, Boolean> each) {
			return false;
		}
		
		abstract boolean resourcePaths(Function<IPath, Boolean> each);
		abstract IPath getPreviewPath();
	}
	
	private final class NodePreviewGenerator extends PreviewGenerator {
		NodePreviewGenerator(IFile file, IResource buildFile) {
			super(file, buildFile);
		}

		@Override
		public IPath getPreviewPath() {
			return file.getRawLocation().removeFileExtension().addFileExtension("html");
		}

		@Override
		public void generatePreview() {
			try {
				ProcessBuilder builder = new ProcessBuilder();
				builder.directory(new File(buildFile.getParent().getRawLocation().toOSString() + "/"));
				builder.command("/usr/bin/node", buildFile.getName());
				builder.start().waitFor();
			} catch (InterruptedException | IOException e) {
				e.printStackTrace();
			}	
		}


		@Override
		public boolean resourcePaths(Function<IPath, Boolean> each) {
			return each.apply(file.getParent().getFullPath());
		}

		@Override
		public boolean ignorePaths(Function<IPath, Boolean> each) {
			return each.apply(file.getFullPath().removeFileExtension().addFileExtension("html"));
		}
	}
	
	private final class MavenPreviewGenerator extends PreviewGenerator {
		MavenPreviewGenerator(IFile file, IResource buildFile) {
			super(file, buildFile);
		}

		@Override
		public IPath getPreviewPath() {
			return buildFile.getParent().getRawLocation().append("target/generated-docs/").append(file.getName()).removeFileExtension().addFileExtension("html");
		}

		@Override
		public void generatePreview() {
			try {
				ProcessBuilder builder = new ProcessBuilder();
				builder.directory(new File(buildFile.getParent().getRawLocation().toOSString() + "/"));
				builder.command("/usr/bin/nice", "/home/apps/apache-maven-3.6.3-bin/apache-maven-3.6.3/bin/mvn", "generate-resources");
				builder.inheritIO();
				builder.start().waitFor();
			} catch (InterruptedException | IOException e) {
				e.printStackTrace();
			}	
		}

		@Override
		public IResource getSourceFile() {
			return file;
		}

		@Override
		public boolean resourcePaths(Function<IPath, Boolean> each) {
			return each.apply(buildFile.getParent().getFullPath());
		}
	}
}
